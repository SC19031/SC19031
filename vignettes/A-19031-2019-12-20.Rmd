---
title: "Homework-2019-12-20"
author: '19031'
date: "12/24/2019"
output: html_document
---




##Question



1.
You have already written an R function for Exercise 9.4 (page 277, Statistical Computing with R). Rewrite an Rcpp function for the same task.

9.4 
Implement a random walk Metropolis sampler for generating the standard Laplace distribution (see Exercise 3.2). For the increment, simulate from a normal distribution. Compare the chains generated when different variances are used for the proposal distribution. Also, compute the acceptance rates of each chain.

2.
Compare the generated random numbers by the two functions using qqplot.

3.
Campare the computation time of the two functions with microbenchmark.

4.
Comments your results.





##Answer


```{r}
library(Rcpp)
library(microbenchmark)

####################################################################
# C++ function.

cppFunction(
  'NumericVector rw_C (double sigma,double x0,int N){
  NumericVector x(N); 
  x[1] = x0; 
  NumericVector u = runif(N); 
  double k = 0;
  for (int i = 2; i < N+1 ;i++){ 
    double y = as<double>(rnorm(1, x[i-1], sigma));
    double t = exp(-abs(y))/exp(-abs(x[i-1]));
    if (u[i] <= t){
      x[i] = y; 
      k = k + 1;
    }
    else{ 
       x[i] = x[i-1];} 
  };
  return x;}')


######################################################################################################################################
f <- function(x) {
  1/2*exp(-abs(x))
}
#g <- function(x,sigma) {dnorm(x,sigma)}
rw_R<-function(sigma,x0,N){
  x<-numeric(N)
  x[1]<-x0
  u<-runif(N)
   k <- 0
  for (i in 2:N) {
    y <- rnorm(1, x[i-1], sigma)
    if (u[i] <= ( f(y) / f(x[i-1]) ))
     x[i] <- y 
    else {
     x[i] <- x[i-1]
     k <- k + 1
   }
  }
return(list(x=x, k=k))
}

#######################################################################################################################################

sigma<-c(0.05,0.1,0.5,2,5,10,20,50,100)
B<-length(sigma)
N<-10000
x0<-20

for (i in 1:B) {
  
Rw<-rw_R(sigma[i],x0,N)
rcpp<-rw_C(sigma[i],x0,N)
ts <- microbenchmark(Rw=rw_R(sigma[i],x0,N), rcpp=rw_C(sigma[i],x0,N))

qqplot(Rw$x,rcpp,ylab="C++ function",xlab = "R function",main= paste("sigma=",sigma[i]))
  abline(a = 0 , b = 1, col = "red") 
print(summary(ts)[,c(1,3,5,6)])
}

```


Conclusion,C ++ 's calculation speed is much better than R's calculation speed. When the sigma value is small, the difference between the two is large. When the sigma becomes large, the results obtained by the two methods tend to be consistent.




   
   
   
   
